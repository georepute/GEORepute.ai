"use client";

import { useCallback } from "react";
import jsPDF from "jspdf";
import { format } from "date-fns";

interface ActionStep {
  step: string;
  description: string;
  priority: string;
  estimatedImpact: string;
  completed: boolean;
  channel?: string;
  platform?: string;
}

interface ActionPlan {
  id: string;
  title: string;
  objective: string;
  steps: ActionStep[];
  reasoning: string;
  expectedOutcome: string;
  timeline: string;
  priority: string;
  category: string;
  projectName?: string;
  domain?: string;
  region?: string;
  channels?: string[];
}

/** Load GeoRepute logo as base64 for PDF */
async function loadGeoReputeLogo(): Promise<string | null> {
  try {
    const logoImg = document.createElement("img") as HTMLImageElement;
    logoImg.crossOrigin = "anonymous";
    return await new Promise<string | null>((resolve) => {
      const t = setTimeout(() => resolve(null), 4000);
      logoImg.onload = () => {
        clearTimeout(t);
        try {
          const c = document.createElement("canvas");
          c.width = 400;
          c.height = 400;
          const ctx = c.getContext("2d");
          if (!ctx) {
            resolve(null);
            return;
          }
          ctx.drawImage(logoImg, 0, 0, 400, 400);
          resolve(c.toDataURL("image/png", 0.95));
        } catch {
          resolve(null);
        }
      };
      logoImg.onerror = () => {
        clearTimeout(t);
        resolve(null);
      };
      logoImg.src = "/logo.png";
    });
  } catch {
    return null;
  }
}

export function useActionPlanExport() {
  const exportToPDF = useCallback(async (plan: ActionPlan) => {
    try {
      const doc = new jsPDF("p", "mm", "a4");
      const pageWidth = doc.internal.pageSize.getWidth();
      const pageHeight = doc.internal.pageSize.getHeight();
      const margin = 20;
      const contentWidth = pageWidth - 2 * margin;

      // Colors (match AI Visibility report)
      const PURPLE = { r: 147, g: 51, b: 234 };
      const PURPLE_DARK = { r: 107, g: 33, b: 168 };
      const GRAY_700 = { r: 55, g: 65, b: 81 };
      const GRAY_500 = { r: 107, g: 114, b: 128 };
      const GRAY_400 = { r: 156, g: 163, b: 175 };

      // Letterhead: header/footer on every page
      const HEADER_HEIGHT = 18;
      const FOOTER_HEIGHT = 14;
      const contentTop = margin + HEADER_HEIGHT;
      const contentBottom = pageHeight - FOOTER_HEIGHT;

      const geoReputeLogoData = await loadGeoReputeLogo();

      const addPageHeader = () => {
        doc.setFillColor(PURPLE.r, PURPLE.g, PURPLE.b);
        doc.rect(0, 0, pageWidth, 14, "F");
        if (geoReputeLogoData) {
          try {
            doc.addImage(geoReputeLogoData, "PNG", margin, 2.5, 9, 9);
          } catch {
            /* ignore */
          }
        }
        doc.setFontSize(9);
        doc.setFont("helvetica", "bold");
        doc.setTextColor(255, 255, 255);
        doc.text("GEORepute.ai", geoReputeLogoData ? margin + 11 : margin, 8.5);
        doc.setFontSize(7);
        doc.setFont("helvetica", "normal");
        doc.text("Digital Business Plan", pageWidth - margin, 8.5, { align: "right" });
        doc.setDrawColor(PURPLE_DARK.r, PURPLE_DARK.g, PURPLE_DARK.b);
        doc.setLineWidth(0.5);
        doc.line(0, 14, pageWidth, 14);
        doc.setTextColor(GRAY_700.r, GRAY_700.g, GRAY_700.b);
      };

      const addPageFooter = (pageNum: number, totalPages: number) => {
        const footerY = pageHeight - 10;
        doc.setDrawColor(GRAY_400.r, GRAY_400.g, GRAY_400.b);
        doc.setLineWidth(0.3);
        doc.line(margin, footerY - 3, pageWidth - margin, footerY - 3);
        doc.setFontSize(7);
        doc.setFont("helvetica", "normal");
        doc.setTextColor(GRAY_500.r, GRAY_500.g, GRAY_500.b);
        doc.text("Confidential - Generated by GEORepute.ai", margin, footerY);
        doc.text(`Page ${pageNum} of ${totalPages}`, pageWidth / 2, footerY, { align: "center" });
        doc.text(
          new Date().toLocaleDateString("en-US", { year: "numeric", month: "long", day: "numeric" }),
          pageWidth - margin,
          footerY,
          { align: "right" }
        );
        doc.setTextColor(GRAY_700.r, GRAY_700.g, GRAY_700.b);
      };

      const lineHeight = 5;
      const lineHeightSmall = 4;

      const checkPageBreak = (requiredSpace: number) => {
        if (yPos + requiredSpace > contentBottom) {
          doc.addPage();
          addPageHeader();
          yPos = contentTop;
        }
      };

      const addWrappedText = (text: string, maxWidth: number, lineH: number = lineHeight) => {
        const lines = doc.splitTextToSize(text || "", maxWidth);
        lines.forEach((line: string) => {
          checkPageBreak(lineH);
          doc.text(line, margin, yPos);
          yPos += lineH;
        });
      };

      // First page header
      addPageHeader();
      let yPos = contentTop;

      // Title
      doc.setFontSize(16);
      doc.setFont("helvetica", "bold");
      doc.setTextColor(GRAY_700.r, GRAY_700.g, GRAY_700.b);
      const titleLines = doc.splitTextToSize(plan.title, contentWidth);
      titleLines.forEach((line: string) => {
        checkPageBreak(lineHeight);
        doc.text(line, margin, yPos);
        yPos += lineHeight;
      });
      yPos += 2;

      doc.setFontSize(8);
      doc.setFont("helvetica", "normal");
      doc.setTextColor(GRAY_500.r, GRAY_500.g, GRAY_500.b);
      const metaParts: string[] = [
        `Generated: ${format(new Date(), "MMM dd, yyyy 'at' hh:mm a")}`,
        plan.projectName && `Project: ${plan.projectName}`,
        plan.domain && `Domain: ${plan.domain}`,
        plan.region && `Region: ${plan.region}`,
        plan.channels && plan.channels.length > 0 && `Channels: ${plan.channels.join(", ")}`,
      ].filter(Boolean) as string[];
      doc.text(metaParts.join(" | "), margin, yPos);
      yPos += 8;

      // Executive Summary
      checkPageBreak(14);
      doc.setFillColor(PURPLE.r, PURPLE.g, PURPLE.b);
      doc.roundedRect(margin, yPos - 1, contentWidth, 8, 1.5, 1.5, "F");
      doc.setFontSize(10);
      doc.setFont("helvetica", "bold");
      doc.setTextColor(255, 255, 255);
      doc.text("Executive Summary", margin + 4, yPos + 5);
      doc.setTextColor(GRAY_700.r, GRAY_700.g, GRAY_700.b);
      yPos += 11;

      doc.setFontSize(9);
      doc.setFont("helvetica", "bold");
      doc.text("Objective", margin, yPos);
      yPos += 5;
      doc.setFont("helvetica", "normal");
      addWrappedText(plan.objective, contentWidth);
      yPos += 2;

      const completedCount = plan.steps.filter((s) => s.completed).length;
      const progressPct =
        plan.steps.length > 0 ? Math.round((completedCount / plan.steps.length) * 100) : 0;

      doc.setFont("helvetica", "bold");
      doc.setFontSize(8);
      doc.text(
        `Timeline: ${plan.timeline} | Category: ${plan.category} | Priority: ${plan.priority}`,
        margin,
        yPos
      );
      yPos += 5;
      doc.text(
        `Progress: ${completedCount}/${plan.steps.length} steps completed (${progressPct}%)`,
        margin,
        yPos
      );
      yPos += 8;

      // Strategic Reasoning
      checkPageBreak(14);
      doc.setFillColor(245, 158, 11);
      doc.roundedRect(margin, yPos - 1, contentWidth, 8, 1.5, 1.5, "F");
      doc.setFontSize(10);
      doc.setFont("helvetica", "bold");
      doc.setTextColor(255, 255, 255);
      doc.text("Strategic Reasoning", margin + 4, yPos + 5);
      doc.setTextColor(GRAY_700.r, GRAY_700.g, GRAY_700.b);
      yPos += 11;

      doc.setFont("helvetica", "normal");
      doc.setFontSize(9);
      addWrappedText(plan.reasoning, contentWidth);
      yPos += 4;

      doc.setFont("helvetica", "bold");
      doc.setFontSize(9);
      doc.text("Expected Outcome", margin, yPos);
      yPos += 5;
      doc.setFont("helvetica", "normal");
      addWrappedText(plan.expectedOutcome, contentWidth);
      yPos += 8;

      // Action Steps
      checkPageBreak(14);
      doc.setFillColor(34, 197, 94);
      doc.roundedRect(margin, yPos - 1, contentWidth, 8, 1.5, 1.5, "F");
      doc.setFontSize(10);
      doc.setFont("helvetica", "bold");
      doc.setTextColor(255, 255, 255);
      doc.text(`Action Steps (${completedCount}/${plan.steps.length} completed)`, margin + 4, yPos + 5);
      doc.setTextColor(GRAY_700.r, GRAY_700.g, GRAY_700.b);
      yPos += 11;

      const stepContentWidth = contentWidth - 4;

      plan.steps.forEach((step, idx) => {
        checkPageBreak(12);
        doc.setFont("helvetica", "bold");
        doc.setFontSize(9);
        doc.setTextColor(GRAY_700.r, GRAY_700.g, GRAY_700.b);
        const stepTitle = `${idx + 1}. ${step.step}`;
        const titleLines = doc.splitTextToSize(stepTitle, stepContentWidth);
        titleLines.forEach((line: string) => {
          checkPageBreak(lineHeight);
          doc.text(line, margin + 4, yPos);
          yPos += lineHeight;
        });
        yPos += 1;

        doc.setFont("helvetica", "normal");
        doc.setFontSize(8);
        doc.setTextColor(GRAY_500.r, GRAY_500.g, GRAY_500.b);
        const descLines = doc.splitTextToSize(step.description || "", stepContentWidth);
        descLines.forEach((line: string) => {
          checkPageBreak(lineHeightSmall);
          doc.text(line, margin + 4, yPos);
          yPos += lineHeightSmall;
        });

        const stepMeta: string[] = [
          `Priority: ${step.priority}`,
          `Impact: ${step.estimatedImpact}`,
          step.channel && `Channel: ${step.channel}`,
          step.platform && `Platform: ${step.platform}`,
          step.completed ? "Status: Completed" : "Status: Pending",
        ].filter(Boolean) as string[];
        doc.text(stepMeta.join(" | "), margin + 4, yPos);
        yPos += 6;
      });

      // Add footer to all pages
      const totalPages = doc.getNumberOfPages();
      for (let i = 1; i <= totalPages; i++) {
        doc.setPage(i);
        addPageFooter(i, totalPages);
      }

      const fileName = `Business_Plan_${(plan.title || "ActionPlan").replace(/\s+/g, "_").slice(0, 40)}_${format(new Date(), "yyyy-MM-dd")}.pdf`;
      doc.save(fileName);

      return { success: true };
    } catch (error) {
      console.error("PDF export error:", error);
      throw error;
    }
  }, []);

  return { exportToPDF };
}
